/**
 * Cloud Functions for aidant-app
 * OpenAI APIをサーバーサイドで呼び出すことでAPIキーを保護
 */

const functions = require('firebase-functions');
const admin = require('firebase-admin');
const OpenAI = require('openai');
const fs = require('fs');
const path = require('path');
// Node.js 18+では fetch がグローバルに利用可能

admin.initializeApp();

// OpenAI クライアント初期化
const openai = new OpenAI({
  apiKey: functions.config().openai?.key || process.env.OPENAI_API_KEY,
});

/**
 * 様式2（経営計画書兼補助事業計画書）生成
 *
 * セキュリティ対策:
 * - Firebase Authentication必須
 * - レート制限（1日10回まで）
 * - ポイント残高チェック
 * - APIキーはサーバーサイドで管理
 */
exports.generateSubsidyApplication = functions
  .region('asia-northeast1') // 東京リージョン
  .https.onCall(async (data, context) => {
    // 認証チェック
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'ユーザー認証が必要です'
      );
    }

    const userId = context.auth.uid;
    const { answers } = data;

    try {
      // ユーザー情報取得
      const userRef = admin.firestore().collection('users').doc(userId);
      const userDoc = await userRef.get();

      if (!userDoc.exists) {
        throw new functions.https.HttpsError(
          'not-found',
          'ユーザー情報が見つかりません'
        );
      }

      const userData = userDoc.data();

      // ポイント残高チェック（様式2生成コスト: 100ポイント）
      const generationCost = 100;
      if ((userData.pointBalance || 0) < generationCost) {
        throw new functions.https.HttpsError(
          'failed-precondition',
          'ポイント残高が不足しています'
        );
      }

      // レート制限チェック（1日10回まで）
      const today = new Date().toISOString().split('T')[0];
      const rateLimitKey = `apiCalls_${today}`;
      const todayCalls = userData[rateLimitKey] || 0;

      if (todayCalls >= 10) {
        throw new functions.https.HttpsError(
          'resource-exhausted',
          '本日の利用上限（10回）に達しました。明日以降再度お試しください。'
        );
      }

      // プロンプト構築（buildApplicationPrompt関数を移植）
      const prompt = buildApplicationPrompt(answers);

      console.log(`[generateSubsidyApplication] User: ${userId}, Attempt: ${todayCalls + 1}/10`);

      // OpenAI API呼び出し
      const completion = await openai.chat.completions.create({
        model: 'gpt-4o',
        messages: [
          {
            role: 'system',
            content: 'あなたは小規模事業者持続化補助金の申請書作成の専門家です。審査に通りやすい高品質な申請書を作成します。必ず「である調（常体）」を使用してください。',
          },
          {
            role: 'user',
            content: prompt,
          },
        ],
        temperature: 0.7,
        max_tokens: 8000,
      });

      const generatedText = completion.choices[0].message.content.trim();

      // ポイント消費とレート制限カウンター更新
      await userRef.update({
        pointBalance: admin.firestore.FieldValue.increment(-generationCost),
        [rateLimitKey]: todayCalls + 1,
        lastApiCallTimestamp: admin.firestore.FieldValue.serverTimestamp(),
      });

      // ポイント使用履歴を記録
      await admin.firestore().collection('point_transactions').add({
        userId: userId,
        type: 'usage',
        amount: -generationCost,
        description: '様式2生成',
        timestamp: admin.firestore.FieldValue.serverTimestamp(),
      });

      console.log(`[generateSubsidyApplication] Success. Points deducted: ${generationCost}`);

      return {
        generatedText,
        pointsUsed: generationCost,
        remainingPoints: (userData.pointBalance || 0) - generationCost,
      };
    } catch (error) {
      console.error('[generateSubsidyApplication] Error:', error);

      // OpenAI APIエラーの場合
      if (error.status) {
        throw new functions.https.HttpsError(
          'internal',
          `OpenAI APIエラー: ${error.message}`
        );
      }

      // その他のエラー
      throw error;
    }
  });

/**
 * 回答の自動補完（AI Draft生成）
 *
 * セキュリティ対策:
 * - Firebase Authentication必須
 * - レート制限（1日50回まで）
 * - ポイント残高チェック（10ポイント/回）
 */
exports.generateAnswerDraft = functions
  .region('asia-northeast1')
  .https.onCall(async (data, context) => {
    // 認証チェック
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'ユーザー認証が必要です'
      );
    }

    const userId = context.auth.uid;
    const { questionText, userInput, context: questionContext } = data;

    try {
      // ユーザー情報取得
      const userRef = admin.firestore().collection('users').doc(userId);
      const userDoc = await userRef.get();

      if (!userDoc.exists) {
        throw new functions.https.HttpsError(
          'not-found',
          'ユーザー情報が見つかりません'
        );
      }

      const userData = userDoc.data();

      // ポイント残高チェック（AI Draft生成コスト: 10ポイント）
      const draftCost = 10;
      if ((userData.pointBalance || 0) < draftCost) {
        throw new functions.https.HttpsError(
          'failed-precondition',
          'ポイント残高が不足しています'
        );
      }

      // レート制限チェック（1日50回まで）
      const today = new Date().toISOString().split('T')[0];
      const rateLimitKey = `draftCalls_${today}`;
      const todayCalls = userData[rateLimitKey] || 0;

      if (todayCalls >= 50) {
        throw new functions.https.HttpsError(
          'resource-exhausted',
          '本日の利用上限（50回）に達しました'
        );
      }

      // OpenAI API呼び出し
      const completion = await openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [
          {
            role: 'system',
            content: '申請書作成のアシスタントとして、ユーザーの簡潔な入力を元に、詳細で説得力のある回答を生成してください。',
          },
          {
            role: 'user',
            content: `
質問: ${questionText}
ユーザーの簡潔な回答: ${userInput}
${questionContext ? `背景情報: ${JSON.stringify(questionContext)}` : ''}

上記を元に、申請書に記載する詳細な回答を生成してください。
`,
          },
        ],
        temperature: 0.7,
        max_tokens: 500,
      });

      const enhancedAnswer = completion.choices[0].message.content.trim();

      // ポイント消費とレート制限カウンター更新
      await userRef.update({
        pointBalance: admin.firestore.FieldValue.increment(-draftCost),
        [rateLimitKey]: todayCalls + 1,
      });

      // ポイント使用履歴を記録
      await admin.firestore().collection('point_transactions').add({
        userId: userId,
        type: 'usage',
        amount: -draftCost,
        description: 'AI Draft生成',
        timestamp: admin.firestore.FieldValue.serverTimestamp(),
      });

      return {
        enhancedAnswer,
        pointsUsed: draftCost,
        remainingPoints: (userData.pointBalance || 0) - draftCost,
      };
    } catch (error) {
      console.error('[generateAnswerDraft] Error:', error);

      if (error.status) {
        throw new functions.https.HttpsError(
          'internal',
          `OpenAI APIエラー: ${error.message}`
        );
      }

      throw error;
    }
  });

/**
 * 回答内容の完成度分析（AI分析）
 *
 * セキュリティ対策:
 * - Firebase Authentication必須
 * - レート制限（1日20回まで）
 * - ポイント残高チェック（5ポイント/回）
 */
exports.analyzeCompleteness = functions
  .region('asia-northeast1')
  .https.onCall(async (data, context) => {
    // 認証チェック
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'ユーザー認証が必要です'
      );
    }

    const userId = context.auth.uid;
    const { answers, placeData } = data;

    try {
      // ユーザー情報取得
      const userRef = admin.firestore().collection('users').doc(userId);
      const userDoc = await userRef.get();

      if (!userDoc.exists) {
        throw new functions.https.HttpsError(
          'not-found',
          'ユーザー情報が見つかりません'
        );
      }

      const userData = userDoc.data();

      // ポイント残高チェック（分析コスト: 5ポイント）
      const analysisCost = 5;
      if ((userData.pointBalance || 0) < analysisCost) {
        throw new functions.https.HttpsError(
          'failed-precondition',
          'ポイント残高が不足しています'
        );
      }

      // レート制限チェック（1日20回まで）
      const today = new Date().toISOString().split('T')[0];
      const rateLimitKey = `analysisCalls_${today}`;
      const todayCalls = userData[rateLimitKey] || 0;

      if (todayCalls >= 20) {
        throw new functions.https.HttpsError(
          'resource-exhausted',
          '本日の利用上限（20回）に達しました'
        );
      }

      // OpenAI API呼び出し
      const completion = await openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [
          {
            role: 'system',
            content: '小規模事業者持続化補助金の申請書（様式2）作成に必要な情報が揃っているか分析する専門家です。JSON形式で必ず回答してください。',
          },
          {
            role: 'user',
            content: buildCompletenessPrompt(answers, placeData),
          },
        ],
        temperature: 0.3,
        max_tokens: 2000,
        response_format: { type: 'json_object' },
      });

      const analysisText = completion.choices[0].message.content.trim();
      const analysis = JSON.parse(analysisText);

      // ポイント消費とレート制限カウンター更新
      await userRef.update({
        pointBalance: admin.firestore.FieldValue.increment(-analysisCost),
        [rateLimitKey]: todayCalls + 1,
      });

      // ポイント使用履歴を記録
      await admin.firestore().collection('point_transactions').add({
        userId: userId,
        type: 'usage',
        amount: -analysisCost,
        description: '完成度分析',
        timestamp: admin.firestore.FieldValue.serverTimestamp(),
      });

      console.log(`[analyzeCompleteness] Success. Overall: ${analysis.overall}%`);

      return {
        analysis,
        pointsUsed: analysisCost,
        remainingPoints: (userData.pointBalance || 0) - analysisCost,
      };
    } catch (error) {
      console.error('[analyzeCompleteness] Error:', error);

      if (error.status) {
        throw new functions.https.HttpsError(
          'internal',
          `OpenAI APIエラー: ${error.message}`
        );
      }

      throw error;
    }
  });

/**
 * 追加質問生成（AI生成）
 *
 * セキュリティ対策:
 * - Firebase Authentication必須
 * - レート制限（1日30回まで）
 * - ポイント残高チェック（10ポイント/回）
 */
exports.generateFollowUpQuestion = functions
  .region('asia-northeast1')
  .https.onCall(async (data, context) => {
    // 認証チェック
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'ユーザー認証が必要です'
      );
    }

    const userId = context.auth.uid;
    const { gaps, answers, placeData } = data;

    try {
      // ユーザー情報取得
      const userRef = admin.firestore().collection('users').doc(userId);
      const userDoc = await userRef.get();

      if (!userDoc.exists) {
        throw new functions.https.HttpsError(
          'not-found',
          'ユーザー情報が見つかりません'
        );
      }

      const userData = userDoc.data();

      // ポイント残高チェック（質問生成コスト: 10ポイント）
      const questionCost = 10;
      if ((userData.pointBalance || 0) < questionCost) {
        throw new functions.https.HttpsError(
          'failed-precondition',
          'ポイント残高が不足しています'
        );
      }

      // レート制限チェック（1日30回まで）
      const today = new Date().toISOString().split('T')[0];
      const rateLimitKey = `followUpCalls_${today}`;
      const todayCalls = userData[rateLimitKey] || 0;

      if (todayCalls >= 30) {
        throw new functions.https.HttpsError(
          'resource-exhausted',
          '本日の利用上限（30回）に達しました'
        );
      }

      // OpenAI API呼び出し
      const completion = await openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [
          {
            role: 'system',
            content: '小規模事業者持続化補助金の申請書作成を支援する質問生成の専門家です。不足情報を埋めるための自然で効果的な質問を1つ生成してください。JSON形式で必ず回答してください。',
          },
          {
            role: 'user',
            content: buildFollowUpQuestionPrompt(gaps, answers, placeData),
          },
        ],
        temperature: 0.7,
        max_tokens: 500,
        response_format: { type: 'json_object' },
      });

      const questionText = completion.choices[0].message.content.trim();
      const questionData = JSON.parse(questionText);

      // ポイント消費とレート制限カウンター更新
      await userRef.update({
        pointBalance: admin.firestore.FieldValue.increment(-questionCost),
        [rateLimitKey]: todayCalls + 1,
      });

      // ポイント使用履歴を記録
      await admin.firestore().collection('point_transactions').add({
        userId: userId,
        type: 'usage',
        amount: -questionCost,
        description: '追加質問生成',
        timestamp: admin.firestore.FieldValue.serverTimestamp(),
      });

      console.log(`[generateFollowUpQuestion] Success. Question ID: ${questionData.id}`);

      return {
        question: questionData,
        pointsUsed: questionCost,
        remainingPoints: (userData.pointBalance || 0) - questionCost,
      };
    } catch (error) {
      console.error('[generateFollowUpQuestion] Error:', error);

      if (error.status) {
        throw new functions.https.HttpsError(
          'internal',
          `OpenAI APIエラー: ${error.message}`
        );
      }

      throw error;
    }
  });

/**
 * buildApplicationPrompt関数
 * フロントエンドのopenai.jsから移植
 */
function buildApplicationPrompt(answers) {
  // ===== Phase 1: 基本情報 =====
  const placeInfo = answers['Q1-0'] || {};
  const businessType = answers['Q1-1'] || '';

  // 法人名と店舗名の処理
  const companyNameType = answers['Q1-2'] || 'same';
  const companyName = answers['Q1-2-company'] || '';
  const storeName = placeInfo.name || '';

  // 法人名が店舗名と異なる場合の表記
  let businessNameDisplay = '';
  if (companyNameType === 'different' && companyName) {
    businessNameDisplay = `${companyName}は${storeName}`;
  } else {
    businessNameDisplay = storeName;
  }

  const mainServices = answers['Q1-3'] || '';
  const additionalServices = answers['Q1-3-multi'] || '';
  const employees = answers['Q1-4'] || '';
  const openingDate = answers['Q1-5'] || '';
  const businessForm = answers['Q1-6'] || '';
  const subsidyPurpose = answers['Q1-7'] || '';
  const annualSales = answers['Q1-8'] || '';
  const salesTrend = answers['Q1-8-trend'] || '';
  const operatingProfit = answers['Q1-9'] || '';
  const grossProfitRate = answers['Q1-10'] || '';
  const customerUnitPrice = answers['Q1-11'] || '';

  // ===== Phase 2: 顧客ニーズと市場の動向 =====
  const targetCustomer = answers['P2-1'] || '';
  const whyChosen = answers['P2-2'] || '';
  const customerNeeds = answers['P2-3'] || '';
  const needsChange = answers['P2-4'] || '';
  const marketTrends = answers['P2-5'] || '';
  const competitorComparison = answers['P2-6'] || '';

  // ===== Phase 3: 自社の強み =====
  const uniqueness = answers['P3-1'] || '';
  const customerValue = answers['P3-2'] || '';
  const expertise = answers['P3-3'] || '';
  const equipment = answers['P3-4'] || '';
  const achievements = answers['P3-5'] || '';
  const weaknesses = answers['P3-6'] || '';
  const location = answers['P3-7'] || '';

  // ===== Phase 4: 経営方針・目標 =====
  const futureGoals = answers['P4-1'] || '';
  const goalPlan = answers['P4-2'] || '';
  const salesTarget = answers['P4-3'] || '';
  const keyInitiatives = answers['P4-4'] || '';
  const targetTimeline = answers['P4-5'] || '';
  const longTermVision = answers['P4-6'] || '';
  const managementChallenges = answers['P4-7'] || '';
  const strengthToLeverage = answers['P4-8'] || '';

  // ===== Phase 5: 補助事業の内容 =====
  const subsidyUsage = answers['P5-1'] || '';
  const plannedEquipment = answers['P5-2'] || '';
  const implementationSchedule = answers['P5-3'] || '';
  const expectedEffect = answers['P5-4'] || '';
  const specificMeasures = answers['P5-5'] || '';
  const targetCustomers = answers['P5-6'] || '';
  const expenseBreakdown = answers['P5-7'] || '';
  const webRelatedExpenses = answers['P5-8'] || '';
  const advertisingPlan = answers['P5-9'] || '';
  const salesIncreaseRationale = answers['P5-10'] || '';
  const regionalContribution = answers['P5-11'] || '';
  const innovationPoints = answers['P5-12'] || '';

  // ===== Phase 6: 文章生成スタイル =====
  const writingTone = answers['P6-1'] || 5;
  const writingDetail = answers['P6-2'] || 3;
  const keywords = answers['P6-3'] || '';

  // スタイル設定を構築
  let styleInstructions = '\n\n【文章スタイル指定】\n';

  // トーンの設定
  switch (writingTone) {
    case 1:
      styleInstructions += '- 堅実で信頼感のある表現を使用する\n';
      styleInstructions += '- 落ち着いた語調で、実績と信頼性を重視する\n';
      styleInstructions += '- 数値データを重視し、長年の経験を強調する\n';
      break;
    case 2:
      styleInstructions += '- 情熱的でやる気が伝わる表現を使用する\n';
      styleInstructions += '- ビジョンと目標達成への強い意志を示す\n';
      styleInstructions += '- 前向きで挑戦的な姿勢を強調する\n';
      break;
    case 3:
      styleInstructions += '- 柔らかく親しみやすい表現を使用する\n';
      styleInstructions += '- お客様目線を重視し、共感を呼ぶストーリーを含める\n';
      styleInstructions += '- 温かみのある語調で、人との関係性を大切にする姿勢を示す\n';
      break;
    case 4:
      styleInstructions += '- 簡潔で論理的な表現を使用する\n';
      styleInstructions += '- データと戦略を重視し、目標達成への道筋を明確に示す\n';
      styleInstructions += '- 効率性と合理性を強調する\n';
      break;
    case 5:
    default:
      styleInstructions += '- バランスの取れた標準的な表現を使用する\n';
      styleInstructions += '- 実績とビジョンの両方を適度に盛り込む\n';
      break;
  }

  // 詳細度の設定
  switch (writingDetail) {
    case 1:
      styleInstructions += '- 具体的な数値、データ、表を多用する\n';
      styleInstructions += '- 定量的な根拠を明確に示す\n';
      break;
    case 2:
      styleInstructions += '- ストーリー性を重視し、創業の経緯や顧客とのエピソードを盛り込む\n';
      styleInstructions += '- 想いや背景を丁寧に説明する\n';
      break;
    case 3:
    default:
      styleInstructions += '- 数値データとストーリーをバランス良く配置する\n';
      break;
  }

  // キーワードの設定
  if (keywords) {
    styleInstructions += `- 以下のキーワードを適切な箇所に自然に組み込む：「${keywords}」\n`;
  }

  const prompt = `
あなたは小規模事業者持続化補助金の申請書作成の専門家です。
以下の情報を元に、審査に通りやすい高品質な「様式2（経営計画書兼補助事業計画書）」を作成してください。

${styleInstructions}

# 【Phase 1】 基本情報

## 事業者情報
- 事業者名: ${businessNameDisplay}
- 店舗名: ${storeName}
${companyNameType === 'different' && companyName ? `- 法人名: ${companyName}\n` : ''}- 住所: ${placeInfo.address || ''}
- 業種: ${businessType}
- 主要サービス: ${mainServices}
${additionalServices && additionalServices !== 'なし' ? `- 追加事業: ${additionalServices}\n` : ''}- 従業員数: ${employees}名
- 開業日: ${openingDate}
- 営業形態: ${businessForm}
- 補助金活用の目的: ${subsidyPurpose}

## 財務情報
- 年間売上: ${annualSales}万円
- 売上の傾向: ${salesTrend}
- 経常利益（営業利益）: ${operatingProfit}万円
- 粗利益率: ${grossProfitRate}%
- 客単価: ${customerUnitPrice}円

# 【Phase 2】 顧客ニーズと市場の動向
- ターゲット顧客: ${targetCustomer}
- 選ばれる理由: ${whyChosen}
- 顧客ニーズ: ${customerNeeds}
- ニーズの変化: ${needsChange}
- 市場トレンド: ${marketTrends}
- 競合比較: ${competitorComparison}

# 【Phase 3】 自社の強み
- 独自性: ${uniqueness}
- 顧客価値: ${customerValue}
- 専門性: ${expertise}
- 設備: ${equipment}
- 実績: ${achievements}
- 弱み・課題: ${weaknesses}
- 立地: ${location}

# 【Phase 4】 経営方針・目標
- 今後の目標: ${futureGoals}
- 目標達成計画: ${goalPlan}
- 売上目標: ${salesTarget}
- 重点施策: ${keyInitiatives}
- 実施時期: ${targetTimeline}
- 長期ビジョン: ${longTermVision}
- 経営課題: ${managementChallenges}
- 活用する強み: ${strengthToLeverage}

# 【Phase 5】 補助事業の内容
- 補助金の使い道: ${subsidyUsage}
- 導入設備: ${plannedEquipment}
- 実施スケジュール: ${implementationSchedule}
- 期待される効果: ${expectedEffect}
- 具体的施策: ${specificMeasures}
- ターゲット顧客: ${targetCustomers}
- 経費内訳: ${expenseBreakdown}
- Web関連費用: ${webRelatedExpenses}
- 広告計画: ${advertisingPlan}
- 売上増加の根拠: ${salesIncreaseRationale}
- 地域貢献: ${regionalContribution}
- 革新性: ${innovationPoints}

---

# 出力形式

以下の構成で様式2を作成してください：

## Ⅰ. 経営計画

### 1. 企業概要（800-1200文字）
- 事業内容、創業年、主要サービス
- 売上構成（表形式）
- 立地特性
- 業務状況と課題

### 2. 顧客ニーズと市場の動向（1200-1800文字）
- 市場全体の動向（出典明記）
- 顧客分析（地域別、商品別）
- 未開拓市場の特定

### 3. 自社や自社の提供する商品・サービスの強み（800-1200文字）
- 箇条書き（●）で複数の強みを列挙
- 顧客評価・口コミ引用
- 競合との差別化ポイント

### 4. 経営方針・目標と今後のプラン（1200-1800文字）
- 現状の課題認識
- 具体的な数値目標
- 実施時期と具体的行動

## Ⅱ. 補助事業計画

### 1. 補助事業で行う事業名（30文字以内）

### 2. 販路開拓等（生産性向上）の取組内容（1500-2500文字）
- 実施する施策の詳細
- 目的、対象顧客、実施時期、方法
- 創意工夫した点

### 3. 補助事業の効果（800-1200文字）
- 売上・取引への効果
- 具体的な数値見込み
- 短期効果と長期効果

---

**重要な指示:**
- 必ず「である調（常体）」を使用すること
- 具体的な数値を積極的に使用すること
- 表形式（Markdown）で財務データを整理すること
- 出典がある場合は必ず明記すること
- 各セクションの文字数目安を守ること
${companyNameType === 'different' && companyName ? `- 法人名と店舗名の使い分け：文章の冒頭や事業概要では「${companyName}は${storeName}という店舗を運営している」のように両方を明記し、その後は文脈に応じて適切に使い分けること\n` : ''}
`;

  return prompt;
}

/**
 * buildCompletenessPrompt関数
 * 完成度分析用のプロンプト構築
 */
function buildCompletenessPrompt(answers, placeData) {
  const prompt = `
あなたは小規模事業者持続化補助金の申請書（様式2）作成に必要な情報が揃っているか分析する専門家です。

# 様式2で必要な情報

## 1. 企業概要（800-1200文字）
必要な情報:
- 事業の概要（創業年、主要サービス、顧客層）
- 事業別の売上高・売上総利益・売上シェア・客単価
- 立地場所の特性
- 主な商品・サービスのリスト（単価、営業利益率）
- 売上ランキング（売上総額TOP3、利益総額TOP3）
- 売上の状況（日次、週次、月次の来客数と売上パターン）
- 業務状況（従業員数、業務内容、課題）

## 2. 顧客ニーズと市場の動向（1200-1800文字）
必要な情報:
- 市場全体の動向（業界統計、トレンド）
- 地域別顧客分布（市町村別の売上構成比）
- 人口に対する顧客数の割合
- 未開拓地域の特定
- 事業別の購入品特徴（商品別売上構成比、季節変動、客単価）

## 3. 自社の強み（800-1200文字）
必要な情報:
- 競合他社と比較して優れている点
- 顧客に評価されている点（口コミ等）
- 品質、技術、サービス、ノウハウ等の強み

## 4. 経営方針・目標と今後のプラン（1200-1800文字）
必要な情報:
- 現状の課題認識
- 今後の経営方針・目標（具体的な数値目標）
- 目標達成のための具体的プラン（時期、行動）

## 5. 補助事業の内容（1500-2500文字）
必要な情報:
- 補助事業で行う事業名（30文字以内）
- 実施する施策の詳細（目的、対象顧客、実施時期、方法）
- 経費の内訳
- 期待される効果（売上増加の数値見込み）

# 現在の回答内容

${JSON.stringify(answers, null, 2)}

# Google Maps情報

${JSON.stringify(placeData, null, 2)}

# 分析タスク

上記の回答内容を分析し、各セクションの完成度を0-100%で評価してください。
また、不足している情報をリストアップしてください。

# 出力形式（JSON）

必ず以下のJSON形式で回答してください：

{
  "overall": 75,
  "sections": {
    "企業概要": {
      "completeness": 80,
      "gaps": ["売上ランキング（TOP3商品）", "日次・週次の売上パターン"]
    },
    "顧客ニーズと市場の動向": {
      "completeness": 60,
      "gaps": ["地域別顧客分布", "未開拓地域の特定", "季節変動パターン"]
    },
    "自社の強み": {
      "completeness": 85,
      "gaps": ["具体的な顧客の声（口コミ引用）"]
    },
    "経営方針・目標": {
      "completeness": 70,
      "gaps": ["具体的な数値目標", "実施時期の明確化"]
    },
    "補助事業の内容": {
      "completeness": 75,
      "gaps": ["売上増加の根拠となる計算式", "地域貢献の具体例"]
    }
  },
  "priority_gaps": [
    {
      "section": "顧客ニーズと市場の動向",
      "gap": "地域別顧客分布",
      "reason": "審査で重視される項目のため",
      "priority": "high"
    },
    {
      "section": "補助事業の内容",
      "gap": "売上増加の根拠となる計算式",
      "reason": "効果の説得力を高めるために必須",
      "priority": "high"
    }
  ]
}
`;

  return prompt;
}

/**
 * buildFollowUpQuestionPrompt関数
 * 追加質問生成用のプロンプト構築
 */
function buildFollowUpQuestionPrompt(gaps, answers, placeData) {
  const prompt = `
あなたは小規模事業者持続化補助金の申請書作成を支援する質問生成の専門家です。

# 不足している情報（優先度順）

${JSON.stringify(gaps, null, 2)}

# 現在の回答内容

${JSON.stringify(answers, null, 2)}

# Google Maps情報

${JSON.stringify(placeData, null, 2)}

# タスク

上記の不足情報を埋めるための質問を1つ生成してください。
最も優先度の高い不足情報から順に質問を作成します。

## 質問作成の方針

1. **自然で答えやすい質問にする**: 専門用語を避け、事業主が日常的に使う言葉で質問する
2. **具体例を示す**: placeholderで回答例を示し、何を答えればよいか明確にする
3. **既存の回答と矛盾しない**: 既に回答済みの内容を踏まえた質問にする
4. **1つの質問で1つの情報を得る**: 複雑な質問は避ける

# 出力形式（JSON）

必ず以下のJSON形式で回答してください：

{
  "id": "AI-F1",
  "text": "お店で特に売れている商品のTOP3を教えてください（売上金額ベース）",
  "type": "textarea",
  "placeholder": "例：1位 ○○（月間売上50万円）、2位 △△（月間売上30万円）、3位 □□（月間売上20万円）",
  "helpText": "審査では具体的な売上データが重視されます。おおよその金額で構いません。",
  "targetSection": "企業概要",
  "targetGap": "売上ランキング（TOP3商品）"
}

type は以下のいずれか:
- "text": 短い回答（1行）
- "textarea": 長い回答（複数行）
- "number": 数値
- "single_select": 選択肢から1つ選択（optionsも含める）
- "multi_select": 選択肢から複数選択（optionsも含める）
`;

  return prompt;
}

/**
 * Webサイトの内容を取得して要約する
 * @param {string} url - WebサイトのURL
 * @returns {Promise<string>} - 要約されたテキスト
 */
async function fetchAndSummarizeWebsite(url) {
  if (!url) return '';

  try {
    console.log(`[fetchWebsite] Fetching: ${url}`);

    // URLの正規化（httpをhttpsに）
    const normalizedUrl = url.replace(/^http:\/\//i, 'https://');

    // HTMLを取得（タイムアウト10秒）
    const response = await fetch(normalizedUrl, {
      timeout: 10000,
      headers: {
        'User-Agent': 'Mozilla/5.0 (compatible; AidantBot/1.0; +https://aidant-app.web.app)',
      },
    });

    if (!response.ok) {
      console.warn(`[fetchWebsite] HTTP error: ${response.status}`);
      return '';
    }

    const html = await response.text();

    // HTMLタグを除去してテキストのみを抽出
    let cleanedText = html
      // scriptとstyleタグの内容を削除
      .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
      .replace(/<style\b[^<]*(?:(?!<\/style>)<[^<]*)*<\/style>/gi, '')
      // HTMLタグを削除
      .replace(/<[^>]+>/g, ' ')
      // HTMLエンティティをデコード
      .replace(/&nbsp;/g, ' ')
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&amp;/g, '&')
      .replace(/&quot;/g, '"')
      .replace(/&#039;/g, "'")
      // 空白を正規化
      .replace(/\s+/g, ' ')
      .replace(/\n+/g, '\n')
      .trim()
      .substring(0, 3000); // 最初の3000文字のみ

    console.log(`[fetchWebsite] Extracted ${cleanedText.length} characters from ${url}`);

    // OpenAI APIで要約
    const completion = await openai.chat.completions.create({
      model: 'gpt-4o-mini', // コスト削減のためminiモデルを使用
      messages: [
        {
          role: 'system',
          content: '以下のWebサイトの内容を、補助金申請書作成に役立つ情報として要約してください。特に、事業内容、強み、特徴、サービス内容、こだわりなどを抽出してください。',
        },
        {
          role: 'user',
          content: cleanedText,
        },
      ],
      temperature: 0.5,
      max_tokens: 500,
    });

    const summary = completion.choices[0].message.content.trim();
    console.log(`[fetchWebsite] Summary created: ${summary.length} characters`);

    return summary;
  } catch (error) {
    console.error(`[fetchWebsite] Error fetching ${url}:`, error.message);
    return ''; // エラーの場合は空文字を返す（処理を続行）
  }
}

/**
 * 店舗プロフィール自動生成
 *
 * Google MapsとWebサイトの情報から店舗プロフィールをAI生成
 *
 * セキュリティ対策:
 * - Firebase Authentication必須
 * - レート制限（1日10回まで）
 * - ポイント残高チェック（15ポイント/回）
 */
exports.generateStoreProfile = functions
  .region('asia-northeast1')
  .https.onCall(async (data, context) => {
    // 認証チェック
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'ユーザー認証が必要です'
      );
    }

    const userId = context.auth.uid;
    const { googleMapsData, websiteUrl } = data;

    try {
      // ユーザー情報取得
      const userRef = admin.firestore().collection('users').doc(userId);
      const userDoc = await userRef.get();

      if (!userDoc.exists) {
        throw new functions.https.HttpsError(
          'not-found',
          'ユーザー情報が見つかりません'
        );
      }

      const userData = userDoc.data();

      // ポイント残高チェック（プロフィール生成コスト: 15ポイント）
      const profileCost = 15;
      if ((userData.pointBalance || 0) < profileCost) {
        throw new functions.https.HttpsError(
          'failed-precondition',
          'ポイント残高が不足しています'
        );
      }

      // レート制限チェック（1日10回まで）
      const today = new Date().toISOString().split('T')[0];
      const rateLimitKey = `profileCalls_${today}`;
      const todayCalls = userData[rateLimitKey] || 0;

      if (todayCalls >= 10) {
        throw new functions.https.HttpsError(
          'resource-exhausted',
          '本日の利用上限（10回）に達しました'
        );
      }

      console.log(`[generateStoreProfile] User: ${userId}, Store: ${googleMapsData.name}`);

      // Webサイト要約取得（複数URL対応）
      let websiteSummary = '';
      const allUrls = [];

      // Google Mapsの公式サイト
      if (googleMapsData.website) {
        allUrls.push(googleMapsData.website);
      }

      // ユーザーが追加入力したURL
      if (websiteUrl) {
        allUrls.push(websiteUrl);
      }

      // 複数URLを順次取得して統合
      if (allUrls.length > 0) {
        const summaries = [];
        for (const url of allUrls) {
          const summary = await fetchAndSummarizeWebsite(url);
          if (summary) {
            summaries.push(`【${url}】\n${summary}`);
          }
        }
        websiteSummary = summaries.join('\n\n');
      }

      // Google Maps口コミのテキスト抽出
      const reviewsText = googleMapsData.reviews
        ? googleMapsData.reviews.slice(0, 5).map(r => r.text).join('\n')
        : '';

      // OpenAI APIでプロフィール生成
      const completion = await openai.chat.completions.create({
        model: 'gpt-4o',
        messages: [
          {
            role: 'system',
            content: '以下のGoogle MapsとWebサイトの情報から、補助金申請に必要な店舗プロフィールを生成してください。必ずJSON形式で回答してください。',
          },
          {
            role: 'user',
            content: `
【Google Maps情報】
店舗名: ${googleMapsData.name}
住所: ${googleMapsData.address || ''}
業種（types）: ${googleMapsData.types?.join(', ') || ''}
評価: ${googleMapsData.rating ? `★${googleMapsData.rating}` : '不明'} (${googleMapsData.userRatingsTotal || 0}件)
価格帯（price_level 1-4）: ${googleMapsData.price_level || '不明'}
営業時間: ${googleMapsData.openingHours?.weekday_text?.join(', ') || '不明'}
電話番号: ${googleMapsData.phoneNumber || ''}
Webサイト: ${googleMapsData.website || 'なし'}

【口コミ（最新5件）】
${reviewsText || 'なし'}

【Webサイト情報】
${websiteSummary || 'なし'}

# タスク

上記の情報を分析し、以下の形式でJSON形式で店舗プロフィールを出力してください：

{
  "businessName": "店舗名",
  "businessType": "業種（日本語で具体的に。例：イタリアンレストラン、美容室、雑貨店）",
  "corporateType": "法人/個人事業主/不明",
  "companyName": "法人名（不明の場合は空文字）",
  "products": ["商品1", "商品2", "商品3"],
  "strengths": ["強み1", "強み2", "強み3"],
  "targetCustomers": ["顧客層1", "顧客層2"],
  "operatingDays": "週○日（営業日数）",
  "estimatedPrice": 1200,
  "rating": 4.5,
  "reviewCount": 120,
  "reviewHighlights": ["評価ポイント1", "評価ポイント2", "評価ポイント3"]
}

## 出力の注意点

1. **businessType**: typesから推測し、日本語で具体的に記述（例：「レストラン」→「イタリアンレストラン」）
2. **corporateType**: 法人名が明示されている場合は「法人」、個人名の場合は「個人事業主」、不明な場合は「不明」
3. **companyName**: 「株式会社〇〇」のような法人名が判明している場合のみ記載
4. **products**: Webサイトやtypesから推測される主要な商品・サービスを3-5個
5. **strengths**: 口コミやWebサイトから読み取れる強みを3-5個
6. **targetCustomers**: 口コミやWebサイトから推測される顧客層を2-3個
7. **operatingDays**: 営業時間から計算（例：「週6日」）
8. **estimatedPrice**: price_levelと業種から推定される客単価（円）
   - price_level 1（安い）: 飲食500-1000円、小売1000-3000円
   - price_level 2（やや安い）: 飲食1500-3000円、小売3000-5000円
   - price_level 3（やや高い）: 飲食3000-5000円、小売5000-10000円
   - price_level 4（高い）: 飲食5000円以上、小売10000円以上
9. **rating**: Google Mapsの評価（そのまま）
10. **reviewCount**: 口コミ件数（そのまま）
11. **reviewHighlights**: 口コミで頻出する評価ポイントを3-5個抽出

**重要**: 必ずJSON形式のみを返してください。説明文は不要です。
`,
          },
        ],
        response_format: { type: 'json_object' },
        temperature: 0.3,
        max_tokens: 1500,
      });

      const profileText = completion.choices[0].message.content.trim();
      const profile = JSON.parse(profileText);

      // ポイント消費とレート制限カウンター更新
      await userRef.update({
        pointBalance: admin.firestore.FieldValue.increment(-profileCost),
        [rateLimitKey]: todayCalls + 1,
      });

      // ポイント使用履歴を記録
      await admin.firestore().collection('point_transactions').add({
        userId: userId,
        type: 'usage',
        amount: -profileCost,
        description: '店舗プロフィール生成',
        timestamp: admin.firestore.FieldValue.serverTimestamp(),
      });

      console.log(`[generateStoreProfile] Success. Business: ${profile.businessType}`);

      return {
        profile,
        websiteSummary,
        pointsUsed: profileCost,
        remainingPoints: (userData.pointBalance || 0) - profileCost,
      };
    } catch (error) {
      console.error('[generateStoreProfile] Error:', error);

      if (error.status) {
        throw new functions.https.HttpsError(
          'internal',
          `OpenAI APIエラー: ${error.message}`
        );
      }

      throw error;
    }
  });

/**
 * Phase 2 会話形式質問生成（テスト用）
 *
 * 業種に応じた会話形式の小質問を生成
 */
exports.generatePhase2ConversationalQuestions = functions
  .region('asia-northeast1')
  .https.onCall(async (data, context) => {
    // 認証チェック
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'ユーザー認証が必要です'
      );
    }

    const userId = context.auth.uid;
    const { businessType, dataItemId, dataItemLabel, collectedData } = data;

    try {
      console.log(`[generatePhase2ConversationalQuestions] User: ${userId}, Business: ${businessType}, DataItem: ${dataItemId}`);

      // Webサイトの情報を取得（Q1-0のwebsiteまたはQ1-0-websiteから）
      let websiteSummary = '';
      let websiteUrl = '';

      // Q1-0のGoogle Maps情報からwebsiteを取得
      if (collectedData && collectedData['Q1-0'] && collectedData['Q1-0'].website) {
        websiteUrl = collectedData['Q1-0'].website;
      }

      // Q1-0-website（手動入力）があればそちらを優先
      if (collectedData && collectedData['Q1-0-website']) {
        websiteUrl = collectedData['Q1-0-website'];
      }

      if (websiteUrl) {
        websiteSummary = await fetchAndSummarizeWebsite(websiteUrl);
      }

      // OpenAI API呼び出し
      const completion = await openai.chat.completions.create({
        model: 'gpt-4o',
        messages: [
          {
            role: 'system',
            content: '小規模事業者持続化補助金の申請書（様式2）作成を支援する質問生成の専門家です。会話形式で、端的に答えられる小質問を生成してください。',
          },
          {
            role: 'user',
            content: buildConversationalQuestionsPrompt(businessType, dataItemId, dataItemLabel, collectedData, websiteSummary),
          },
        ],
        temperature: 0.7,
        max_tokens: 2000,
        response_format: { type: 'json_object' },
      });

      const resultText = completion.choices[0].message.content.trim();
      const result = JSON.parse(resultText);

      console.log(`[generatePhase2ConversationalQuestions] Success. Generated ${result.questions?.length || 0} questions`);

      return result;
    } catch (error) {
      console.error('[generatePhase2ConversationalQuestions] Error:', error);

      if (error.status) {
        throw new functions.https.HttpsError(
          'internal',
          `OpenAI APIエラー: ${error.message}`
        );
      }

      throw error;
    }
  });

/**
 * Phase 2 回答統合
 *
 * 会話形式の小質問の回答を自然な文章に統合
 */
exports.consolidatePhase2Answers = functions
  .region('asia-northeast1')
  .https.onCall(async (data, context) => {
    // 認証チェック
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'ユーザー認証が必要です'
      );
    }

    const userId = context.auth.uid;
    const { businessType, dataItemId, dataItemLabel, conversationAnswers } = data;

    try {
      console.log(`[consolidatePhase2Answers] User: ${userId}, DataItem: ${dataItemId}`);

      // OpenAI API呼び出し
      const completion = await openai.chat.completions.create({
        model: 'gpt-4o',
        messages: [
          {
            role: 'system',
            content: '申請書作成のアシスタントとして、会話の回答を自然な文章に統合してください。である調（常体）で記述し、数値は使わず定性的な表現にしてください。',
          },
          {
            role: 'user',
            content: buildConsolidationPrompt(businessType, dataItemId, dataItemLabel, conversationAnswers),
          },
        ],
        temperature: 0.7,
        max_tokens: 500,
      });

      const consolidatedText = completion.choices[0].message.content.trim();

      console.log(`[consolidatePhase2Answers] Success`);

      return { consolidatedText };
    } catch (error) {
      console.error('[consolidatePhase2Answers] Error:', error);

      if (error.status) {
        throw new functions.https.HttpsError(
          'internal',
          `OpenAI APIエラー: ${error.message}`
        );
      }

      throw error;
    }
  });

/**
 * 知識ベースのMarkdownファイルを読み込む
 *
 * @param {string} businessType - 業種（'飲食業' など）
 * @param {string} section - セクション（'顧客ニーズ' など）
 * @returns {string} 知識ベースの内容（Markdown形式）
 */
function loadKnowledgeBase(businessType, section) {
  try {
    // 業種名を正規化（ファイルパスに使用可能な形式に）
    const normalizedBusinessType = businessType.replace(/[\/\\?%*:|"<>]/g, '_');

    // 知識ベースのディレクトリパス（functionsディレクトリ内）
    const knowledgeDir = path.join(__dirname, 'knowledge_base', businessType);

    // ディレクトリが存在しない場合は空文字列を返す
    if (!fs.existsSync(knowledgeDir)) {
      console.log(`[loadKnowledgeBase] Directory not found: ${knowledgeDir}`);
      return '';
    }

    // セクションに関連するファイルを検索
    const files = fs.readdirSync(knowledgeDir)
      .filter(file => {
        // セクション名が含まれるファイル、またはすべてのファイル
        return file.endsWith('.md') && (file.includes(section) || section === '全般');
      })
      .sort(); // ファイル名順にソート

    if (files.length === 0) {
      console.log(`[loadKnowledgeBase] No knowledge files found for ${businessType} / ${section}`);
      return '';
    }

    // ファイルを読み込んで結合
    const knowledgeContent = files.map(file => {
      const filePath = path.join(knowledgeDir, file);
      const content = fs.readFileSync(filePath, 'utf-8');
      return content;
    }).join('\n\n---\n\n');

    console.log(`[loadKnowledgeBase] Loaded ${files.length} knowledge file(s) for ${businessType} / ${section}`);
    return knowledgeContent;
  } catch (error) {
    console.error('[loadKnowledgeBase] Error:', error);
    return '';
  }
}

/**
 * 会話形式質問生成用のプロンプト構築
 */
function buildConversationalQuestionsPrompt(businessType, dataItemId, dataItemLabel, collectedData, websiteSummary = '') {
  const websiteInfo = websiteSummary ? `\n\n# 公式Webサイトからの情報\n\n${websiteSummary}\n` : '';

  // 知識ベースを読み込む（Phase 2は「顧客ニーズ」セクション）
  const knowledgeBase = loadKnowledgeBase(businessType, '顧客ニーズ');
  const knowledgeInfo = knowledgeBase ? `\n\n# 参考知識（外部コンテンツから抽出）\n\nあなたは中小企業診断士レベルのAIです。以下の知識を参考に、採択率の高い質問を生成してください。\n\n${knowledgeBase}\n` : '';

  const prompt = `
業種: ${businessType}
${websiteInfo}
${knowledgeInfo}
「顧客ニーズと市場の動向」のセクションで、以下のデータ項目について情報収集します：
- データ項目ID: ${dataItemId}
- データ項目名: ${dataItemLabel}

# タスク

この業種に最適な、会話形式の小質問を3-5個生成してください。

## 質問作成の方針

1. **端的に答えられる質問**: Yes/No、選択式、または1-2行で答えられる質問
2. **業種に特化した質問**: この業種特有の表現や状況を考慮
3. **回答例を提示**: 理想的な回答例をplaceholderに記載（虚偽でなければOK）
4. **定性的な表現**: 「少し増えた」「かなり減った」など、数値ではなく感覚で答えられる選択肢
5. **自然な会話**: 形式的ではなく、会話しているような自然な質問文
6. **複数選択を優先**: 選択肢がある場合は、できるだけ"multi_select"を使用（ユーザーが複数回答できるようにする）

既に収集済みの情報:
${JSON.stringify(collectedData, null, 2)}

# 出力形式（JSON）

必ず以下のJSON形式で回答してください：

{
  "questions": [
    {
      "id": "conv-1",
      "text": "主なお客様の年齢層を教えてください（複数選択可）",
      "type": "multi_select",
      "options": ["10代以下", "20代", "30代", "40代", "50代", "60代以上", "幅広い年齢層"],
      "example": ["30代", "40代"]
    },
    {
      "id": "conv-2",
      "text": "お客様の特徴を教えてください（複数選択可）",
      "type": "multi_select",
      "options": ["ファミリー層が多い", "カップルが多い", "一人客が多い", "団体客が多い", "ビジネス利用が多い"],
      "example": ["ファミリー層が多い", "カップルが多い"]
    },
    {
      "id": "conv-3",
      "text": "他に特徴はありますか？",
      "type": "text",
      "placeholder": "例：リピーターが多い",
      "example": "リピーターが多い",
      "optional": true
    }
  ]
}

type は以下のいずれか:
- "text": 短い回答（1行） - 補足情報や任意回答に使用
- "textarea": 長い回答（複数行） - 詳細な説明が必要な場合
- "number": 数値
- "single_select": 選択肢から1つだけ選択（optionsも含める） - 排他的な選択肢の場合のみ使用
- "multi_select": 選択肢から複数選択（optionsも含める）【推奨】 - 基本的にこれを使用

**重要**:
1. 選択肢がある質問は、原則として"multi_select"を使用してください。
2. **必ず最後の選択肢に「その他」を追加してください**。ユーザーが予想外の回答をする場合に備えます。
3. optional: true の場合、「他にもありますか？」のような任意質問

**「その他」選択肢の例**:
{
  "id": "conv-1",
  "text": "主なお客様の年齢層を教えてください（複数選択可）",
  "type": "multi_select",
  "options": ["10代以下", "20代", "30代", "40代", "50代", "60代以上", "幅広い年齢層", "その他"],
  "example": ["30代", "40代"]
}

「その他」を選択した場合、次の質問でテキスト入力を求めます。
`;

  return prompt;
}

/**
 * 回答統合用のプロンプト構築
 */
function buildConsolidationPrompt(businessType, dataItemId, dataItemLabel, conversationAnswers) {
  const prompt = `
業種: ${businessType}
データ項目: ${dataItemLabel}

以下の会話の回答を、自然な文章（2-3文）に統合してください。
数値は使わず、定性的な表現にしてください。

会話の回答:
${JSON.stringify(conversationAnswers, null, 2)}

# 出力形式

である調（常体）で、自然な文章として統合してください。
文章のみを返してください（JSONではありません）。

例:
「主な顧客は30代〜40代の女性が中心で、ファミリー層が多い。週末は家族連れの来店が特に目立つ。」
`;

  return prompt;
}

/**
 * Phase 3 会話形式質問生成
 *
 * 業種に応じた会話形式の小質問を生成（自社の強み）
 */
exports.generatePhase3ConversationalQuestions = functions
  .region('asia-northeast1')
  .https.onCall(async (data, context) => {
    // 認証チェック
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'ユーザー認証が必要です'
      );
    }

    const userId = context.auth.uid;
    const { businessType, dataItemId, dataItemLabel, collectedData } = data;

    try {
      console.log(`[generatePhase3ConversationalQuestions] User: ${userId}, Business: ${businessType}, DataItem: ${dataItemId}`);

      // Webサイトの情報を取得（Q1-0のwebsiteまたはQ1-0-websiteから）
      let websiteSummary = '';
      let websiteUrl = '';

      // Q1-0のGoogle Maps情報からwebsiteを取得
      if (collectedData && collectedData['Q1-0'] && collectedData['Q1-0'].website) {
        websiteUrl = collectedData['Q1-0'].website;
      }

      // Q1-0-website（手動入力）があればそちらを優先
      if (collectedData && collectedData['Q1-0-website']) {
        websiteUrl = collectedData['Q1-0-website'];
      }

      if (websiteUrl) {
        websiteSummary = await fetchAndSummarizeWebsite(websiteUrl);
      }

      // OpenAI API呼び出し
      const completion = await openai.chat.completions.create({
        model: 'gpt-4o',
        messages: [
          {
            role: 'system',
            content: '小規模事業者持続化補助金の申請書（様式2）作成を支援する質問生成の専門家です。「自社の強み」セクション向けの会話形式で、端的に答えられる小質問を生成してください。',
          },
          {
            role: 'user',
            content: buildPhase3QuestionsPrompt(businessType, dataItemId, dataItemLabel, collectedData, websiteSummary),
          },
        ],
        temperature: 0.7,
        max_tokens: 2000,
        response_format: { type: 'json_object' },
      });

      const resultText = completion.choices[0].message.content.trim();
      const result = JSON.parse(resultText);

      console.log(`[generatePhase3ConversationalQuestions] Success. Generated ${result.questions?.length || 0} questions`);

      return result;
    } catch (error) {
      console.error('[generatePhase3ConversationalQuestions] Error:', error);

      if (error.status) {
        throw new functions.https.HttpsError(
          'internal',
          `OpenAI APIエラー: ${error.message}`
        );
      }

      throw error;
    }
  });

/**
 * Phase 3 回答統合
 *
 * 会話形式の小質問の回答を自然な文章に統合（自社の強み）
 */
exports.consolidatePhase3Answers = functions
  .region('asia-northeast1')
  .https.onCall(async (data, context) => {
    // 認証チェック
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'ユーザー認証が必要です'
      );
    }

    const userId = context.auth.uid;
    const { businessType, dataItemId, dataItemLabel, conversationAnswers } = data;

    try {
      console.log(`[consolidatePhase3Answers] User: ${userId}, DataItem: ${dataItemId}`);

      // OpenAI API呼び出し
      const completion = await openai.chat.completions.create({
        model: 'gpt-4o',
        messages: [
          {
            role: 'system',
            content: '申請書作成のアシスタントとして、会話の回答を自然な文章に統合してください。である調（常体）で記述し、具体的な強みや差別化ポイントを明確に表現してください。',
          },
          {
            role: 'user',
            content: buildPhase3ConsolidationPrompt(businessType, dataItemId, dataItemLabel, conversationAnswers),
          },
        ],
        temperature: 0.7,
        max_tokens: 500,
      });

      const consolidatedText = completion.choices[0].message.content.trim();

      console.log(`[consolidatePhase3Answers] Success`);

      return { consolidatedText };
    } catch (error) {
      console.error('[consolidatePhase3Answers] Error:', error);

      if (error.status) {
        throw new functions.https.HttpsError(
          'internal',
          `OpenAI APIエラー: ${error.message}`
        );
      }

      throw error;
    }
  });

/**
 * Phase 3 会話形式質問生成用のプロンプト構築
 */
function buildPhase3QuestionsPrompt(businessType, dataItemId, dataItemLabel, collectedData, websiteSummary = '') {
  const websiteInfo = websiteSummary ? `\n\n# 公式Webサイトからの情報\n\n${websiteSummary}\n` : '';

  // 知識ベースを読み込む（Phase 3は「強み」セクション）
  const knowledgeBase = loadKnowledgeBase(businessType, '強み');
  const knowledgeInfo = knowledgeBase ? `\n\n# 参考知識（外部コンテンツから抽出）\n\nあなたは中小企業診断士レベルのAIです。以下の知識を参考に、採択率の高い質問を生成してください。\n\n${knowledgeBase}\n` : '';

  const prompt = `
業種: ${businessType}
${websiteInfo}
${knowledgeInfo}
「自社の強み」のセクションで、以下のデータ項目について情報収集します：
- データ項目ID: ${dataItemId}
- データ項目名: ${dataItemLabel}

# タスク

この業種に最適な、会話形式の小質問を3-5個生成してください。

## 質問作成の方針

1. **端的に答えられる質問**: Yes/No、選択式、または1-2行で答えられる質問
2. **業種に特化した質問**: この業種特有の強みや差別化ポイントを引き出す
3. **回答例を提示**: 理想的な回答例をplaceholderに記載（虚偽でなければOK）
4. **具体性を重視**: 「品質が良い」ではなく、「どのような品質のこだわりがあるか」を聞く
5. **自然な会話**: 形式的ではなく、会話しているような自然な質問文
6. **複数選択を優先**: 選択肢がある場合は、できるだけ"multi_select"を使用（ユーザーが複数回答できるようにする）

既に収集済みの情報:
${JSON.stringify(collectedData, null, 2)}

# 業種別の質問例

## 飲食業の場合:
- 「お客様から特に評価されている料理やメニューはありますか？（複数選択可）」
- 「食材や調理方法でこだわっている点は何ですか？（複数選択可）」
- 「競合店と比べて、あなたのお店ならではの特徴は何ですか？（複数選択可）」
- 「Google Mapsの口コミで、よく褒められるポイントは何ですか？（複数選択可）」

/**
 * Q1-0回答後に立地データを自動取得
 *
 * 取得データ:
 * 1. 最寄り駅からの距離（Distance Matrix API）
 * 2. 半径1km以内の競合店舗数（Nearby Search API）
 * 3. 競合店舗の平均評価
 */
exports.fetchLocationData = functions
  .region('asia-northeast1')
  .https.onCall(async (data, context) => {
    // 認証チェック（オプション：必要に応じて有効化）
    // if (!context.auth) {
    //   throw new functions.https.HttpsError('unauthenticated', 'ユーザー認証が必要です');
    // }

    const { lat, lng, businessType, address } = data;

    console.log(`[fetchLocationData] Start: lat=${lat}, lng=${lng}, businessType=${businessType}`);

    if (!lat || !lng) {
      throw new functions.https.HttpsError('invalid-argument', '緯度経度が必要です');
    }

    try {
      // 1. 最寄り駅を検索して距離を取得
      const stationData = await getNearestStationDistance(lat, lng);
      console.log('[fetchLocationData] Station data:', stationData);

      // 2. 競合店舗数を取得
      const competitorsData = await getNearbyCompetitors(lat, lng, businessType);
      console.log('[fetchLocationData] Competitors data:', competitorsData);

      return {
        nearestStation: stationData,
        competitors: competitorsData
      };
    } catch (error) {
      console.error('[fetchLocationData] Error:', error);

      // エラーでも処理を続行（データなしでも質問は進める）
      return {
        nearestStation: null,
        competitors: null,
        error: error.message
      };
    }
  });

/**
 * 最寄り駅からの距離を取得
 * @param {number} lat - 緯度
 * @param {number} lng - 経度
 * @returns {Promise<Object|null>} { name, walkingTime, walkingDistance }
 */
async function getNearestStationDistance(lat, lng) {
  const GOOGLE_MAPS_API_KEY = functions.config().google?.maps_api_key || process.env.GOOGLE_MAPS_API_KEY;

  if (!GOOGLE_MAPS_API_KEY) {
    console.warn('[getNearestStationDistance] Google Maps API key not configured');
    return null;
  }

  try {
    // Step 1: 最寄りの駅を検索（Nearby Search APIでtype=train_station）
    const searchUrl = `https://maps.googleapis.com/maps/api/place/nearbysearch/json?location=${lat},${lng}&rankby=distance&type=train_station&key=${GOOGLE_MAPS_API_KEY}`;

    const searchResponse = await fetch(searchUrl);
    const searchData = await searchResponse.json();

    if (!searchData.results || searchData.results.length === 0) {
      console.log('[getNearestStationDistance] No train station found');
      return null;
    }

    const nearestStation = searchData.results[0];
    const stationName = nearestStation.name;
    const stationLat = nearestStation.geometry.location.lat;
    const stationLng = nearestStation.geometry.location.lng;

    console.log(`[getNearestStationDistance] Nearest station: ${stationName}`);

    // Step 2: Distance Matrix APIで徒歩時間・距離を取得
    const distanceUrl = `https://maps.googleapis.com/maps/api/distancematrix/json?origins=${lat},${lng}&destinations=${stationLat},${stationLng}&mode=walking&key=${GOOGLE_MAPS_API_KEY}`;

    const distanceResponse = await fetch(distanceUrl);
    const distanceData = await distanceResponse.json();

    const element = distanceData.rows[0]?.elements[0];

    if (!element || element.status !== 'OK') {
      console.log('[getNearestStationDistance] Distance calculation failed');
      return null;
    }

    return {
      name: stationName,
      walkingTime: element.duration.text, // "15 mins"
      walkingDistance: element.distance.text // "1.2 km"
    };
  } catch (error) {
    console.error('[getNearestStationDistance] Error:', error);
    return null;
  }
}

/**
 * 半径1km以内の競合店舗を取得
 * @param {number} lat - 緯度
 * @param {number} lng - 経度
 * @param {string} businessType - 業種
 * @returns {Promise<Object|null>} { radius, count, avgRating }
 */
async function getNearbyCompetitors(lat, lng, businessType) {
  const GOOGLE_MAPS_API_KEY = functions.config().google?.maps_api_key || process.env.GOOGLE_MAPS_API_KEY;

  if (!GOOGLE_MAPS_API_KEY) {
    console.warn('[getNearbyCompetitors] Google Maps API key not configured');
    return null;
  }

  try {
    // 業種に応じたGoogle Places APIのtypeを設定
    const typeMap = {
      'カフェ': 'cafe',
      'レストラン': 'restaurant',
      '飲食店': 'restaurant',
      '居酒屋': 'bar',
      'バー': 'bar',
      '美容室': 'beauty_salon',
      '理容室': 'hair_care',
      'エステ': 'spa',
      'ネイルサロン': 'beauty_salon',
      'マッサージ': 'spa',
      '小売店': 'store',
      '雑貨店': 'store',
      'アパレル': 'clothing_store',
      '書店': 'book_store',
      '食品販売': 'store'
    };

    // 業種キーワードでマッチング
    let placeType = 'store'; // デフォルト
    for (const [keyword, type] of Object.entries(typeMap)) {
      if (businessType && businessType.includes(keyword)) {
        placeType = type;
        break;
      }
    }

    console.log(`[getNearbyCompetitors] Searching for type: ${placeType}`);

    const url = `https://maps.googleapis.com/maps/api/place/nearbysearch/json?location=${lat},${lng}&radius=1000&type=${placeType}&key=${GOOGLE_MAPS_API_KEY}`;

    const response = await fetch(url);
    const data = await response.json();

    if (!data.results) {
      console.log('[getNearbyCompetitors] No results');
      return null;
    }

    const places = data.results;
    const count = places.length;

    // 評価がある店舗のみで平均を計算
    const placesWithRating = places.filter(p => p.rating);
    const avgRating = placesWithRating.length > 0
      ? (placesWithRating.reduce((sum, p) => sum + p.rating, 0) / placesWithRating.length).toFixed(1)
      : null;

    console.log(`[getNearbyCompetitors] Found ${count} places, avg rating: ${avgRating}`);

    return {
      radius: 1000, // メートル
      count: count,
      avgRating: avgRating ? parseFloat(avgRating) : null
    };
  } catch (error) {
    console.error('[getNearbyCompetitors] Error:', error);
    return null;
  }
}

## 小売業の場合:
- 「お客様から特に評価されている商品は何ですか？（複数選択可）」
- 「商品の仕入れや品揃えでこだわっている点は何ですか？（複数選択可）」
- 「競合店と比べて、あなたのお店ならではの強みは何ですか？（複数選択可）」
- 「リピーターの方はなぜあなたのお店を選ぶのでしょうか？（複数選択可）」

## サービス業の場合:
- 「お客様から特に評価されているサービスは何ですか？（複数選択可）」
- 「技術やサービスでこだわっている点は何ですか？（複数選択可）」
- 「競合と比べて、あなたのサービスならではの特徴は何ですか？（複数選択可）」
- 「お客様が「また来たい」と思う理由は何だと思いますか？（複数選択可）」

# 出力形式（JSON）

必ず以下のJSON形式で回答してください：

{
  "questions": [
    {
      "id": "conv-1",
      "text": "お客様から特に評価されている点は何ですか？（複数選択可）",
      "type": "multi_select",
      "options": ["料理の味", "雰囲気", "接客サービス", "価格", "立地", "こだわりの食材", "独自性"],
      "example": ["料理の味", "雰囲気"]
    },
    {
      "id": "conv-2",
      "text": "食材や調理方法でこだわっている点は何ですか？（複数選択可）",
      "type": "multi_select",
      "options": ["地元食材を使用", "有機野菜を使用", "手作りにこだわる", "伝統的な調理法", "独自のレシピ"],
      "example": ["地元食材を使用", "手作りにこだわる"]
    },
    {
      "id": "conv-3",
      "text": "競合店と比べて、あなたのお店ならではの特徴は何ですか？",
      "type": "text",
      "placeholder": "例：シェフの経歴、独自の仕入れルート、特別なメニュー",
      "example": "イタリアで修行したシェフの本格的なパスタ",
      "optional": true
    }
  ]
}

type は以下のいずれか:
- "text": 短い回答（1行） - 補足情報や任意回答に使用
- "textarea": 長い回答（複数行） - 詳細な説明が必要な場合
- "number": 数値
- "single_select": 選択肢から1つだけ選択（optionsも含める） - 排他的な選択肢の場合のみ使用
- "multi_select": 選択肢から複数選択（optionsも含める）【推奨】 - 基本的にこれを使用

**重要**:
1. 選択肢がある質問は、原則として"multi_select"を使用してください。
2. **必ず最後の選択肢に「その他」を追加してください**。ユーザーが予想外の回答をする場合に備えます。
3. optional: true の場合、「他にもありますか？」のような任意質問

**「その他」選択肢の例**:
{
  "id": "conv-1",
  "text": "お客様から特に評価されている点は何ですか？（複数選択可）",
  "type": "multi_select",
  "options": ["料理の味", "雰囲気", "接客サービス", "価格", "立地", "こだわりの食材", "独自性", "その他"],
  "example": ["料理の味", "雰囲気"]
}

「その他」を選択した場合、次の質問でテキスト入力を求めます。
`;

  return prompt;
}

/**
 * Phase 3 回答統合用のプロンプト構築
 */
function buildPhase3ConsolidationPrompt(businessType, dataItemId, dataItemLabel, conversationAnswers) {
  const prompt = `
業種: ${businessType}
データ項目: ${dataItemLabel}

以下の会話の回答を、自然な文章（2-3文）に統合してください。
具体的な強みや差別化ポイントを明確に表現してください。

会話の回答:
${JSON.stringify(conversationAnswers, null, 2)}

# 出力形式

である調（常体）で、自然な文章として統合してください。
文章のみを返してください（JSONではありません）。

# 統合の方針

1. 具体的な強みを箇条書きではなく、自然な文章で表現
2. 顧客評価や差別化ポイントを明確に記述
3. 数値は使わず、定性的な表現にする
4. 「〜である」「〜だ」など、である調で統一

例（飲食業の場合）:
「当店の最大の強みは、イタリアで修行したシェフによる本格的なパスタである。地元の有機野菜を使用し、手作りにこだわることで、料理の味と雰囲気の両面で高い評価を得ている。リピーターからは「他では味わえない本場の味」との声が多く寄せられている。」

例（サービス業の場合）:
「当店の強みは、一人ひとりのお客様に合わせたカウンセリングと技術力である。10年以上の経験を持つスタッフが丁寧に対応し、お客様の要望を的確に形にすることで高い満足度を実現している。口コミでは「技術力の高さ」「親身な対応」が特に評価されている。」
`;

  return prompt;
}


/**
 * 外部WebサイトURL（食べログ・ホットペッパー等）から構造化データを取得
 */
exports.fetchWebsiteData = functions
  .region('asia-northeast1')
  .https.onCall(async (data, context) => {
    if (!context.auth) {
      throw new functions.https.HttpsError('unauthenticated', 'ユーザー認証が必要です');
    }

    const { url } = data;
    if (!url) {
      throw new functions.https.HttpsError('invalid-argument', 'URLが指定されていません');
    }

    console.log('[fetchWebsiteData] Fetching:', url);

    try {
      const response = await fetch(url, {
        headers: { 'User-Agent': 'Mozilla/5.0 (compatible; AidantBot/1.0)' },
      });

      if (!response.ok) {
        throw new Error(`HTTP error: ${response.status}`);
      }

      const html = await response.text();
      const htmlSnippet = html.substring(0, 30000);

      let prompt = '';
      if (url.includes('tabelog.com')) {
        prompt = `以下の食べログページのHTMLから、以下の情報をJSON形式で抽出してください：
1. rating (評価点数、数値、例: 3.5)
2. reviewCount (口コミ件数、数値のみ)
3. budget (予算、文字列、例: "¥3,000～¥3,999")
4. popularDishes (人気メニュー、文字列配列、最大3つ)
5. keywords (よく使われているキーワード、文字列配列、最大5つ)
情報が見つからない場合はnullを返してください。JSONのみを返してください。
HTML: ${htmlSnippet}`;
      } else if (url.includes('hotpepper.jp')) {
        prompt = `以下のホットペッパービューティーページのHTMLから、以下の情報をJSON形式で抽出してください：
1. rating (評価点数、数値、例: 4.5)
2. reviewCount (口コミ件数、数値のみ)
3. popularMenus (人気メニュー、文字列配列、最大3つ)
4. priceRange (価格帯、文字列、例: "¥5,000～¥10,000")
5. keywords (よく使われているキーワード、文字列配列、最大5つ)
情報が見つからない場合はnullを返してください。JSONのみを返してください。
HTML: ${htmlSnippet}`;
      } else {
        throw new functions.https.HttpsError('invalid-argument', 'サポートされていないURL');
      }

      const completion = await openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [
          { role: 'system', content: 'WebページからJSON形式でデータを抽出してください。' },
          { role: 'user', content: prompt },
        ],
        temperature: 0.1,
        max_tokens: 1000,
        response_format: { type: 'json_object' },
      });

      const extractedData = JSON.parse(completion.choices[0].message.content.trim());
      console.log('[fetchWebsiteData] Success:', extractedData);

      return {
        success: true,
        data: { ...extractedData, sourceUrl: url, fetchedAt: admin.firestore.Timestamp.now() },
      };
    } catch (error) {
      console.error('[fetchWebsiteData] Error:', error);
      throw new functions.https.HttpsError('internal', `エラー: ${error.message}`);
    }
  });

/**
 * 公式WebサイトURLから要約を生成
 */
exports.summarizeWebsite = functions
  .region('asia-northeast1')
  .https.onCall(async (data, context) => {
    if (!context.auth) {
      throw new functions.https.HttpsError('unauthenticated', 'ユーザー認証が必要です');
    }

    const { url } = data;
    if (!url) {
      throw new functions.https.HttpsError('invalid-argument', 'URLが指定されていません');
    }

    console.log('[summarizeWebsite] Fetching:', url);

    try {
      const summary = await fetchAndSummarizeWebsite(url);

      if (!summary) {
        throw new Error('要約の生成に失敗しました');
      }

      console.log('[summarizeWebsite] Success');

      return {
        success: true,
        summary: summary,
      };
    } catch (error) {
      console.error('[summarizeWebsite] Error:', error);
      throw new functions.https.HttpsError('internal', `エラー: ${error.message}`);
    }
  });

/**
 * 会話履歴を記録（Phase 2-6の詳細な会話記録）
 *
 * 記録される情報:
 * - AI生成質問とユーザー回答
 * - 生成されたプロンプト
 * - 様式2の内容
 * - ユーザーのフィードバック・修正
 */
exports.saveConversationHistory = functions
  .region('asia-northeast1')
  .https.onCall(async (data, context) => {
    // 認証チェック
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'ユーザー認証が必要です'
      );
    }

    const userId = context.auth.uid;
    const { conversationId, phase, questionData, answer, metadata } = data;

    try {
      console.log(`[saveConversationHistory] User: ${userId}, Phase: ${phase}, Conversation: ${conversationId}`);

      const db = admin.firestore();

      // 会話履歴コレクション
      const conversationRef = db.collection('conversation_history').doc(conversationId);

      // conversationIdが新規の場合、ドキュメントを作成
      const conversationDoc = await conversationRef.get();

      if (!conversationDoc.exists) {
        // 新規会話の場合、基本情報を作成
        await conversationRef.set({
          userId: userId,
          createdAt: admin.firestore.FieldValue.serverTimestamp(),
          updatedAt: admin.firestore.FieldValue.serverTimestamp(),
          businessType: metadata?.businessType || '',
          category: metadata?.category || '',
          phases: {}
        });
      }

      // Phaseごとのデータを更新
      const phaseData = {
        questions: admin.firestore.FieldValue.arrayUnion({
          questionId: questionData?.id || '',
          questionText: questionData?.text || '',
          questionType: questionData?.type || '',
          generatedPrompt: questionData?.prompt || '',
          answer: answer,
          timestamp: admin.firestore.FieldValue.serverTimestamp()
        }),
        lastUpdated: admin.firestore.FieldValue.serverTimestamp()
      };

      await conversationRef.update({
        [`phases.${phase}`]: phaseData,
        updatedAt: admin.firestore.FieldValue.serverTimestamp()
      });

      console.log(`[saveConversationHistory] Success`);

      return { success: true };
    } catch (error) {
      console.error('[saveConversationHistory] Error:', error);
      throw new functions.https.HttpsError('internal', `エラー: ${error.message}`);
    }
  });

/**
 * 様式2生成時に完全な会話履歴とフィードバックを記録
 */
exports.saveForm2Generation = functions
  .region('asia-northeast1')
  .https.onCall(async (data, context) => {
    // 認証チェック
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'ユーザー認証が必要です'
      );
    }

    const userId = context.auth.uid;
    const { conversationId, generatedForm2, allAnswers } = data;

    try {
      console.log(`[saveForm2Generation] User: ${userId}, Conversation: ${conversationId}`);

      const db = admin.firestore();
      const conversationRef = db.collection('conversation_history').doc(conversationId);

      await conversationRef.update({
        generatedForm2: {
          content: generatedForm2,
          generatedAt: admin.firestore.FieldValue.serverTimestamp(),
          allAnswers: allAnswers
        },
        updatedAt: admin.firestore.FieldValue.serverTimestamp()
      });

      console.log(`[saveForm2Generation] Success`);

      return { success: true };
    } catch (error) {
      console.error('[saveForm2Generation] Error:', error);
      throw new functions.https.HttpsError('internal', `エラー: ${error.message}`);
    }
  });

/**
 * ユーザーが様式2を修正した内容を記録
 */
exports.saveUserFeedback = functions
  .region('asia-northeast1')
  .https.onCall(async (data, context) => {
    // 認証チェック
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'ユーザー認証が必要です'
      );
    }

    const userId = context.auth.uid;
    const { conversationId, section, originalText, correctedText, rating } = data;

    try {
      console.log(`[saveUserFeedback] User: ${userId}, Conversation: ${conversationId}, Section: ${section}`);

      const db = admin.firestore();
      const conversationRef = db.collection('conversation_history').doc(conversationId);

      const feedback = {
        section: section,
        originalText: originalText,
        correctedText: correctedText,
        rating: rating || null,
        timestamp: admin.firestore.FieldValue.serverTimestamp()
      };

      await conversationRef.update({
        userFeedback: admin.firestore.FieldValue.arrayUnion(feedback),
        updatedAt: admin.firestore.FieldValue.serverTimestamp()
      });

      console.log(`[saveUserFeedback] Success`);

      return { success: true };
    } catch (error) {
      console.error('[saveUserFeedback] Error:', error);
      throw new functions.https.HttpsError('internal', `エラー: ${error.message}`);
    }
  });
