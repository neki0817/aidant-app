# セキュリティ対策 - 現状分析と推奨事項

## 実施日
2025年10月23日

---

## 🔒 現在のセキュリティ状況

### ✅ 実装済みの対策

#### 1. Firebase Authentication（認証）
- ユーザー認証が実装されている
- `isAuthenticated()`でログイン状態を確認

#### 2. Firestore Security Rules（データベースアクセス制御）
```javascript
// ユーザーは自分のデータのみアクセス可能
function isOwner(userId) {
  return request.auth.uid == userId;
}

// applications コレクション
match /applications/{applicationId} {
  allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
  allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
  allow update: if isAuthenticated() && resource.data.userId == request.auth.uid;
  allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
}
```

**効果:**
- ✅ ログインしないとデータにアクセスできない
- ✅ 他のユーザーのデータは見られない
- ✅ 自分の申請書データのみ読み書き可能

#### 3. 環境変数の保護
- `.env`ファイルにAPIキーを保存
- `.gitignore`で`.env`を除外（Git管理外）
- Firebase APIキー、Gemini APIキーが環境変数から取得

**効果:**
- ✅ APIキーがGitHubに公開されない
- ✅ 開発環境と本番環境で設定を分離可能

---

## ⚠️ 現在のリスクと問題点

### 問題1: フロントエンドでのAPIキー露出

**現状:**
```javascript
// firebase.js
const firebaseConfig = {
  apiKey: process.env.REACT_APP_FIREBASE_API_KEY, // ← ブラウザから見える
  authDomain: process.env.REACT_APP_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.REACT_APP_FIREBASE_PROJECT_ID,
  // ...
};
```

**リスク:**
- React環境変数（`REACT_APP_*`）はビルド時にバンドルされる
- ブラウザのDevToolsでAPIキーが見える
- 悪意のあるユーザーがAPIキーを取得可能

**ただし、Firebaseの場合:**
- Firebase APIキーは「公開されることを前提」としている
- Firestore Security Rulesで実際のアクセス制御を行う
- APIキーだけではデータにアクセスできない

**結論:** 現状は問題なし（Firebaseの設計思想に沿っている）

### 問題2: Gemini APIキーの露出リスク

**現状:**
```javascript
// gemini.js
const genAI = new GoogleGenerativeAI(process.env.REACT_APP_GEMINI_API_KEY);
```

**リスク:**
- ⚠️ **重大**: Gemini APIキーがフロントエンドに露出
- 悪意のあるユーザーがAPIキーを取得して悪用可能
- API使用量の不正利用 → 課金額の急増

**結論:** **これは大きな問題。バックエンド化が必須**

### 問題3: 個人情報の保存場所

**現状:**
```javascript
// Firestoreに以下のデータを保存
{
  answers: {
    'Q1-0': { name: '店舗名', address: '住所' },
    'Q1-2': '代表者名',
    'Q1-14': 1440, // 売上
    'Q1-15': 150,  // 利益
    // ... 全54質問の回答
  }
}
```

**保存される個人情報:**
- 店舗名、住所、電話番号
- 代表者名
- 売上・利益（財務データ）
- Google Mapsの口コミ情報
- 経営課題・弱み

**現在の保護:**
- ✅ Firestore Security Rulesで保護されている
- ✅ 本人以外はアクセスできない
- ✅ SSL/TLS通信（HTTPS）で暗号化

**リスク:**
- ⚠️ Firebase Adminユーザー（管理者）は全データを見られる
- ⚠️ データベースのバックアップ管理が必要

### 問題4: 生成された申請書の取り扱い

**現状:**
```javascript
// 申請書をブラウザでダウンロード
const handleDownload = () => {
  const element = document.createElement('a');
  const file = new Blob([generatedDocument.content], { type: 'text/markdown' });
  element.href = URL.createObjectURL(file);
  element.download = `補助金申請書_${new Date().toISOString().split('T')[0]}.md`;
  // ...
};
```

**リスク:**
- ⚠️ ダウンロードしたファイルが端末に保存される
- 端末のセキュリティに依存（紛失、盗難等）

---

## 🛡️ 推奨するセキュリティ対策

### 【優先度: 高】必須対策

#### 1. Gemini APIキーのバックエンド化

**現状の問題:**
フロントエンドでGemini APIを直接呼び出し → APIキー露出

**解決策:**
Firebase Cloud Functionsを使用してバックエンド化

**実装例:**
```javascript
// functions/index.js (Firebase Cloud Functions)
const functions = require('firebase-functions');
const { GoogleGenerativeAI } = require('@google/generative-ai');

exports.generateApplication = functions.https.onCall(async (data, context) => {
  // 認証チェック
  if (!context.auth) {
    throw new functions.https.HttpsError('unauthenticated', 'ログインが必要です');
  }

  // ユーザーのデータか確認
  const userId = context.auth.uid;
  const applicationId = data.applicationId;

  // Firestoreから申請データを取得（Security Rules適用）
  const doc = await admin.firestore()
    .collection('applications')
    .doc(applicationId)
    .get();

  if (!doc.exists || doc.data().userId !== userId) {
    throw new functions.https.HttpsError('permission-denied', 'アクセス権限がありません');
  }

  // Gemini APIキーは環境変数から取得（サーバー側のみ）
  const genAI = new GoogleGenerativeAI(functions.config().gemini.api_key);

  // 申請書を生成
  const result = await genAI.generateContent(/* ... */);

  return { content: result.text() };
});
```

**フロントエンド側:**
```javascript
// src/services/gemini/gemini.js
import { httpsCallable } from 'firebase/functions';
import { functions } from '../firebase';

export const generateSubsidyApplication = async (applicationId) => {
  const generateApp = httpsCallable(functions, 'generateApplication');
  const result = await generateApp({ applicationId });
  return result.data.content;
};
```

**メリット:**
- ✅ APIキーがフロントエンドに露出しない
- ✅ サーバー側で認証・認可チェック
- ✅ API使用量の制御が可能

#### 2. データの暗号化

**推奨事項:**
Firestore Field Encryption（フィールド暗号化）

**暗号化すべきデータ:**
- 代表者名
- 財務データ（売上、利益）
- 経営課題・弱み

**実装例:**
```javascript
// src/utils/encryption.js
import CryptoJS from 'crypto-js';

const ENCRYPTION_KEY = process.env.REACT_APP_ENCRYPTION_KEY; // ユーザーごとに異なるキー

export const encryptData = (data) => {
  return CryptoJS.AES.encrypt(JSON.stringify(data), ENCRYPTION_KEY).toString();
};

export const decryptData = (encryptedData) => {
  const bytes = CryptoJS.AES.decrypt(encryptedData, ENCRYPTION_KEY);
  return JSON.parse(bytes.toString(CryptoJS.enc.Utf8));
};
```

**注意:**
- 暗号化キーの管理が重要
- ユーザーごとに異なるキーを使用
- パスワード派生キー（PBKDF2等）の使用を推奨

#### 3. 入力データのバリデーション

**サーバー側でのバリデーション:**
```javascript
// functions/index.js
exports.saveAnswer = functions.https.onCall(async (data, context) => {
  if (!context.auth) {
    throw new functions.https.HttpsError('unauthenticated', 'ログインが必要です');
  }

  const { questionId, answer } = data;

  // バリデーション
  if (typeof answer !== 'string' || answer.length > 10000) {
    throw new functions.https.HttpsError('invalid-argument', '不正な入力です');
  }

  // XSS対策: HTMLタグの除去
  const sanitizedAnswer = answer.replace(/<[^>]*>/g, '');

  // Firestoreに保存
  await admin.firestore()
    .collection('applications')
    .doc(data.applicationId)
    .update({
      [`answers.${questionId}`]: sanitizedAnswer
    });
});
```

### 【優先度: 中】推奨対策

#### 4. Rate Limiting（API呼び出し制限）

**目的:** API悪用の防止

**実装例:**
```javascript
// functions/index.js
const rateLimit = require('express-rate-limit');

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15分
  max: 10, // 最大10回
  message: 'リクエストが多すぎます。しばらくしてから再試行してください。'
});

exports.generateApplication = functions.https.onRequest((req, res) => {
  limiter(req, res, async () => {
    // 申請書生成処理
  });
});
```

#### 5. セッションタイムアウト

**実装:**
```javascript
// src/contexts/AuthContext.jsx
useEffect(() => {
  const TIMEOUT_DURATION = 30 * 60 * 1000; // 30分
  let timeoutId;

  const resetTimeout = () => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      signOut(auth); // 自動ログアウト
      alert('セッションがタイムアウトしました。再度ログインしてください。');
    }, TIMEOUT_DURATION);
  };

  // ユーザー操作時にタイムアウトをリセット
  window.addEventListener('mousemove', resetTimeout);
  window.addEventListener('keydown', resetTimeout);

  return () => {
    clearTimeout(timeoutId);
    window.removeEventListener('mousemove', resetTimeout);
    window.removeEventListener('keydown', resetTimeout);
  };
}, []);
```

#### 6. ログの記録

**監査ログの実装:**
```javascript
// functions/index.js
exports.logAccess = functions.firestore
  .document('applications/{applicationId}')
  .onUpdate((change, context) => {
    const before = change.before.data();
    const after = change.after.data();

    // 変更内容をログに記録
    return admin.firestore().collection('audit_logs').add({
      userId: after.userId,
      applicationId: context.params.applicationId,
      action: 'update',
      timestamp: admin.firestore.FieldValue.serverTimestamp(),
      changedFields: Object.keys(after).filter(key => before[key] !== after[key])
    });
  });
```

### 【優先度: 低】追加対策

#### 7. 二要素認証（2FA）

Firebase Authenticationで実装可能

#### 8. IPアドレス制限

特定のIPアドレスからのみアクセスを許可（企業向け）

#### 9. データの定期削除

一定期間後に自動削除（GDPR対応）

---

## 📋 公開テスト時の推奨手順

### Phase 1: クローズドテスト（現在）

**対象:** 知人のみ
**期間:** 1-2週間

**実施すべき対策:**
1. ✅ Firebase Security Rulesの確認（実装済み）
2. ✅ `.env`ファイルの`.gitignore`登録（実装済み）
3. ⚠️ **Gemini APIキーのバックエンド化（必須）**
4. テストデータの使用（実際の個人情報は使わない）

**テスト手順:**
```
1. 知人にテストアカウントを発行
2. 架空のデータでテスト（例: イタリアンレストラン「トラットリア・ベッラ」）
3. セキュリティチェック:
   - DevToolsでAPIキーが見えないか確認
   - 他のユーザーのデータにアクセスできないか確認
   - 生成された申請書の品質確認
4. フィードバック収集
```

### Phase 2: ベータテスト（準備中）

**対象:** 限定公開（招待制）
**期間:** 1-2ヶ月

**必須対策:**
1. ✅ Gemini APIキーのバックエンド化（Phase 1で実施）
2. データの暗号化（代表者名、財務データ）
3. Rate Limiting（API呼び出し制限）
4. セッションタイムアウト
5. プライバシーポリシーの作成
6. 利用規約の作成

### Phase 3: 一般公開（将来）

**対象:** 一般ユーザー

**追加対策:**
1. 二要素認証（2FA）
2. 監査ログの実装
3. データバックアップ体制の構築
4. インシデント対応体制の整備
5. 個人情報保護法への対応
6. セキュリティ診断の実施

---

## 🚨 現時点での緊急対応

### 今すぐ実施すべきこと

#### 1. Gemini APIキーのバックエンド化（最優先）

**作業内容:**
1. Firebase Cloud Functionsのセットアップ
2. `generateApplication`関数の実装
3. フロントエンドの修正
4. デプロイ

**所要時間:** 2-3時間

**実装しないリスク:**
- ❌ APIキーが盗まれる可能性
- ❌ 不正なAPI使用 → 高額請求
- ❌ サービス停止のリスク

#### 2. テストデータの準備

**推奨:**
知人のテスト時は架空のデータを使用

**テストデータ例:**
```
店舗名: トラットリア・ベッラ（架空）
代表者: テスト太郎
住所: 東京都渋谷区テスト1-2-3
売上: 1440万円（架空）
```

#### 3. プライバシーポリシーの作成

**最低限の記載内容:**
- 収集する個人情報の種類
- 利用目的
- 第三者提供の有無
- 保存期間
- 問い合わせ先

---

## ✅ セキュリティチェックリスト

### 公開前チェック

- [ ] **Gemini APIキーがバックエンド化されている**（最重要）
- [ ] Firebase Security Rulesが正しく設定されている
- [ ] `.env`ファイルが`.gitignore`に登録されている
- [ ] APIキーがGitHubに公開されていない
- [ ] プライバシーポリシーが作成されている
- [ ] 利用規約が作成されている
- [ ] テストデータで動作確認済み

### 運用中チェック

- [ ] 定期的なログの確認
- [ ] 不審なアクセスの監視
- [ ] APIキーの定期的なローテーション
- [ ] セキュリティアップデートの適用
- [ ] バックアップの確認

---

## 📚 参考資料

### Firebase Security
- [Firebase Security Rules](https://firebase.google.com/docs/rules)
- [Firebase Authentication](https://firebase.google.com/docs/auth)

### セキュリティベストプラクティス
- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [個人情報保護法ガイドライン](https://www.ppc.go.jp/)

---

## 📞 問い合わせ

セキュリティに関する懸念事項がある場合は、公開前に必ず相談してください。

**実装完了日:** 2025年10月23日
**次回レビュー:** Gemini APIバックエンド化後
